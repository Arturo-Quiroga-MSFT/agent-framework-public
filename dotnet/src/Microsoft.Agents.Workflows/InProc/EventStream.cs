// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Agents.Workflows.InProc;

/// <summary>
/// Collects events generated by workflow executors and provides views of this stream as an <see cref="IAsyncEnumerable{WorkflowEvent}"/>.
///
/// While there are no consumers of the stream, it will accumulate events in memory. The first consumer is considered the "primary" consumer,
/// in that it will immediately capture the existing events, and stream them out. Subsequent consumers (and the primary after finishing
/// streaming the existing events) will only receive new events as they are generated.
/// </summary>
internal class EventStream : IDisposable
{
    private readonly DataWaiter _incomingWaiter = new();
    private int _isJoined = 0;
    private int _isHalted = 0;

    private List<WorkflowEvent> _incoming = new();
    private List<WorkflowEvent> _outgoing = new();

    public void AddEvent(WorkflowEvent workflowEvent)
    {
        this._incoming.Add(workflowEvent);
        this._incomingWaiter.Signal();
    }

    public bool SignalHalt()
    {
        bool isNewHalt = Interlocked.Exchange(ref this._isHalted, 1) == 0;
        this._incomingWaiter.Signal();

        return isNewHalt;
    }

    public ValueTask JoinWaitForEventAsync(CancellationToken cancellation = default)
        => this._incomingWaiter.JoinWaitForDataAsync(cancellation);

    private bool TryTakeStream()
    {
        return Interlocked.Exchange(ref this._isJoined, 1) == 0;
    }

    public async IAsyncEnumerable<WorkflowEvent> JoinStreamAsync([EnumeratorCancellation] CancellationToken cancellation = default)
    {
        // Initially, it is going to be an error to JoinStreamAsync twice on a single stream, because managing
        // the cross-task behaviour is complex.
        if (!this.TryTakeStream())
        {
            throw new InvalidOperationException("Cannot join the event stream more than once.");
        }

        try
        {
            while (!cancellation.IsCancellationRequested)
            {
                if (this._outgoing.Count == 0)
                {
                    this._incomingWaiter.Reset();
                    this._outgoing = Interlocked.Exchange(ref this._incoming, new());
                    if (this._outgoing.Count == 0)
                    {
                        if (this._isHalted == 1)
                        {
                            this._isHalted = 0;
                            yield break;
                        }
                        else
                        {
                            await this._incomingWaiter.JoinWaitForDataAsync(cancellation).ConfigureAwait(false);
                        }
                    }
                }

                foreach (var workflowEvent in this._outgoing)
                {
                    yield return workflowEvent;
                }
                this._outgoing.Clear();
            }
        }
        finally
        {
            // Once we finish the stream, we reset the state so that it can be reused.
            Interlocked.Exchange(ref this._isJoined, 0);
        }
    }

    public void Dispose()
    {
        this._incomingWaiter.Dispose();
    }
}
